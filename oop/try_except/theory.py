# Виды исключений:
# Исключения при исполнении программы & Исключения при компиляции

# открытие файлов на чтение или запись
# программист не может заранее знать, есть ли такой файл на диске или нет.
# Поэтому, такую строчку нужно выполнять в специальном блоке try с
# обработкой исключения типа FileNotFoundError:
try:
    file = open("myfile2.txt")
except FileNotFoundError:
    print("Невозможно открыть файл")

# при делении одного числа на другое:
# обработка двух исключений
try:
    x, y = map(int, input().split())
    res = x / y
except ZeroDivisionError:
    print("Делить на ноль нельзя!")
except ValueError:
    print("Ошибка типа данных")

# Если мы хотим при возникновении ошибок взаимодействовать с
# объектами классов исключений, то это делается так:
try:
    x, y = map(int, input().split())
    res = x / y
except ZeroDivisionError as z:
    print(z)  # зед содержит системное описание исключения
except ValueError as z:
    print(z)

# Поэтому, вместо указания конкретного типа
# ZeroDivisionError можно указать любой из базовых классов исключений:

try:
    x, y = map(int, input().split())
    res = x / y
except ArithmeticError:  # обработка всех арифмет. исключений
    print("Делить на ноль нельзя!")
except ValueError:
    print("Ошибка типа данных")
# Но здесь есть один важный нюанс. Если вместо ArithmeticError прописать
# класс Exception – общий для классов ArithmeticError и ValueError,
# то первым блоком exception будут отлавливаться все типовые исключения.
# А блок с ValueError никогда выполнен не будет. Поэтому здесь есть
# одно простое правило. Сначала прописываются блоки со специализированными
# классами исключений, а затем с более общими (базовыми).

# И последнее, что я хочу отметить про блок except. Его можно
# прописывать без указания каких-либо классов, следующим образом:

try:
    x, y = map(int, input().split())
    res = x / y
except:
    print("Ошибка")

# В этом случае он будет отлавливать все исключения, возникающие в блоке try.
