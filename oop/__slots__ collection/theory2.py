'__________________ __SLOTS__ при объекте свойстве_________________'


class Point2D:
    __slots__ = ('x', 'y', '__length')  # приватное свойство в slots

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.length = (x*x + y*y) ** 0.5

    @property
    def length(self):
        return self.__length

    @length.setter
    def length(self, value):
        self.__length = value


pt = Point2D(1, 2)
print(pt.length)
# мы здесь обращаемся к свойству length, хотя в __slots__ нет такого
# разрешенного имени. И при этом нет никаких ошибок выполнения. В принципе,
# так и должно быть, потому что length – это не локальная переменная
# экземпляра класса, а атрибут класса Point2D. Коллекция __slots__
# не накладывает ограничения на атрибуты класса, только на локальные
# атрибуты его экземпляров. Благодаря этому и появляется свойство length,
# которое работает как геттер и сеттер класса Point2D.

'___________Поведение __slots__ при наследовании классов__________________'


class Point3D(Point2D):
    __slots__ = 'z',  # без этой записи slots не будет
    # работать у дочернего класса Point3D
    # c этой записью slots наследуется
    # имена x, y будут наследоваться от класса Point2D,
    # а z – добавляться классом Point3D

    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z


pt3 = Point3D(10, 20, 30)
pt3.z = 40
# по умолчанию эта коллекция не наследуется дочерними классами и они ведут
# себя как обычные, без каких-либо ограничений, сохраняя все локальные
# свойства, используя коллекцию: pt3.__dict__
