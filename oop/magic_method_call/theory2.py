# ____________________________ФУНКТОРЫ___________________________________
# Первый пример – это использование класса с методом __call__
# вместо замыканий функций. Смотрите, мы можем объявить класс
# StripChars, который бы удалял вначале и в конце строки заданные символы:
import math


class StripChars:
    def __init__(self, chars):
        self.__chars = chars

    def __call__(self, *args, **kwargs):
        if not isinstance(args[0], str):
            raise ValueError("Аргумент должен быть строкой")

        return args[0].strip(self.__chars)


# Для этого, в инициализаторе мы сохраняем строку __chars – удаляемые символы,
# а затем, при вызове метода __call__ удаляем символы через строковый метод
# strip для символов __chars. То есть, теперь можно создать экземпляр класса
# и указать те символы, которые следует убирать:

s1 = StripChars("?:!.; ")
res = s1(" Hello World! ")

# В результате объект s1 будет отвечать за удаление указанных символов в начале
# и конце строки. Но нам ничто не мешает определять другие объекты этого класса
# с другим набором символов:

s2 = StripChars(" ")
res2 = s2(" Hello World! ")
print(res, res2, sep='\n')

# То есть, объект s2 уже отвечает только за удаление пробелов, тогда как s1 и
# некоторых других символов. Достаточно элегантное решение задачи,
# где нам требуется сохранять символы для удаления.
# ____________________________КЛАССЫ_ДЕКОРАТОРЫ_________________________________

# Второй пример – это реализация декораторов с помощью классов.
# Ранее мы с вами создавали декоратор для вычисления значения производной
# функции в определенной точке x. Я повторю эту реализацию, но с использованием
# класса. Вначале запишем следующий класс:


class Derivate:
    def __init__(self, func):
        self.__fn = func

    def __call__(self, x, dx=0.0001, *args, **kwargs):
        return (self.__fn(x + dx) - self.__fn(x)) / dx


# Далее, определим функцию, например, просто синус:
def df_sin(x):
    return math.sin(x)


# Здесь в инициализаторе сохраняем ссылку на функцию, которую декорируем,
# а в методе __call__ принимаем один обязательный параметр x – точку,
# где вычисляется производная и dx – шаг изменения при вычислении производной.

# Вызов без декорирования
print(df_sin(math.pi/4))
# После запуска программы увидим значение примерно 0.7071. Давайте теперь
# добавим декоратор. Это можно сделать двумя способами.
# Первый, прописать все в явном виде:
df_sin = Derivate(df_sin)
print(df_sin(math.pi/4))
# Теперь df_sin – это экземпляр класса Derivate, а не исходная функция.
# Поэтому, когда она будет вызываться, то запустится метод __call__ и
# вычислится значение производной в точке math.pi/4.

# Второй способ – это воспользоваться оператором @ перед объявлением функции:


@Derivate
def df_sin(x):
    return math.sin(x)
# Получим абсолютно тот же самый результат. Вот принцип создания декораторов
# функций на основе классов. Как видите, все достаточно просто – запоминаем
# ссылку на функцию, а затем, расширяем ее функционал в магическом методе call
