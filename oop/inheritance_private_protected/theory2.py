'_________________________ЗАЩИЩЕННЫЕ АТТРИБУТЫ___________________________'
# Если же нам нужно определить закрытые атрибуты, доступные в текущем классе
# и во всех его дочерних классах, то для этого следует использовать метод
# определения protected – одно нижнее подчеркивание. Поэтому правильнее было
# бы создавать свойства-координаты в базовом инициализаторе в режиме protected:


class Geom:
    __name = 'Geom'

    def __init__(self, x1, y1, x2, y2):
        print(f"инициализатор {self.__class__}")
        self._x1 = x1
        self._y1 = y1
        self._x2 = x2
        self._y2 = y2
        self._name = self.__name

    'ПРИВАТНОСТЬ ЗАПРЕЩАЕТ ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ В ДОЧЕРНИХ КЛАССАХ.'
    def __verify_coord(self, coord):
        return 0 <= coord <= 100


class Rect(Geom):
    def __init__(self, x1, y1, x2, y2, fill='red'):
        super().__init__(x1, y1, x2, y2)
        self._fill = fill
        # self._name = self.__name к приватным атрибутам уровня класса нельзя
        # обратиться ни напрямую, ни через экземпляры дочерних классов
        # Только внутри самого класса  GEOM

    def get_coords(self):
        return (self._x1, self._y1, self._x2, self._y2)
#  Тогда никаких проблем с доступом уже не возникает:


r = Rect(0, 0, 10, 20)
print(r.__dict__)
r.get_coords()
# режим доступа protected в реальности никак не ограничивает доступ
# к атрибутам объектов класса или самого класса. Например, мы можем
# обратиться к координатам напрямую через экземпляр класса:
# print(r._x1)
# Никаких ошибок не будет. Нижнее подчеркивание лишь предупреждает
# (сигнализирует) программиста о защищенном атрибуте, к которому
# напрямую лучше не обращаться. Этот атрибут был создан для внутренней
# логики работы алгоритма в классе и не предназначен для обращения извне.
# В дальнейшем это может привести к проблемам, например, при изменении
# версии класса, в котором такого атрибута уже не будет,
# или он будет играть другую роль и т.п.
'__________Атрибуты private и protected на уровне класса______________'
# Все также работает и с атрибутами уровня класса. Например, сейчас
# мы совершенно спокойно можем обратиться к свойству name класса
# Geom через объект класса Rect:
# print(r.name)
# Добавив одно нижнее подчеркивание, функционал останется прежним, мы
# лишь отметим, что к этой переменной извне лучше не обращаться:
# print(r.__name)
# Но, если прописать два подчеркивания, то доступ будет закрыт всюду,
# кроме самого класса Geom:
# print(r.__name)
# Те же ограничения доступа можно накладывать и на методы. Если в
# базовом классе Geom определить приватный метод, например, для проверки
# корректности значений координат: то он будет доступен только внутри
# этого класса и вызвать его, скажем, в дочернем классе Rect уже не получится:
'''ПРИВАТНОСТЬ ЗАПРЕЩАЕТ ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ В ДОЧЕРНИХ КЛАССАХ. Если же у
метода прописать только одно подчеркивание, то его можно будет вызывать
во всех дочерних классах.'''
