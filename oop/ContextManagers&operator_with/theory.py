# С менеджером контекста мы с вами уже сталкивались, когда
# рассматривали работу с файлами. Rогда открываем
# файловый поток с помощью функции open(), то в конце работы с ним,
# его желательно закрыть с помощью метода close(). Если реализовать
# эту логику через конструкцию try/except/finally, то получим примерно
# вот такой текст программы:
# Благодаря блоку finally мы гарантированно закрываем файл,
# даже если в блоке try возникло какое-либо исключение.
'______________Работа с файлами через конструкцию  try/except_________'
fp = None
try:
    fp = open("myfile.txt")
    for t in fp:
        print(t)
except Exception as e:
    print(e)
finally:
    if fp is not None:
        fp.close()


'_________Работа с файлами через менеджер контекства WITH/AS_________'
# В целом менеджер контекста – это класс, в котором реализованы два магических метода:
# __enter__() и __exit__()
# Когда происходит создание менеджера контекста с помощью оператора with, то
# автоматически вызывается метод класса __enter__. А когда менеджер контекста
# завершает свою работу (программа внутри него выполнилась или произошло исключение),
# то вызывается метод __exit__.
# в файловом менеджере происходит закрытие файлового потока именно в методе __exit__.
# ________________________________________________________________________
# Далее, общий синтаксис вызова менеджера, следующий:
# with <менеджер контекста> as <переменная>:
#      список конструкций языка Python
# Здесь «переменная» - это ссылка на экземпляр менеджера контекста, через
# которую, мы потом с ним можем работать. При необходимости ее можно опустить
# и записать все вот в таком виде:
# with <менеджер контекста>:
#      список конструкций языка Python
# Но тогда мы не сможем обратиться к объекту менеджера контекста.
# _______________________________________________________________________

fp = None
try:
    with open("myfile.txt") as fp:
        for t in fp:
            print(t)
except Exception as e:
    print(e)
